<!DOCTYPE HTML>
<html lang="cn" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>边界框（包围盒） - pbr-book-4ed</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../src/css/style.css">
        <link rel="stylesheet" href="../theme/pagetoc.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">原版目录</a></li><li class="chapter-item expanded affix "><a href="../Preface/index.html">前言</a></li><li class="chapter-item expanded "><a href="../1_Introduction/index.html"><strong aria-hidden="true">1.</strong> 引言</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../1_Introduction/1_1_Literate_Programming.html"><strong aria-hidden="true">1.1.</strong> 文艺编程</a></li><li class="chapter-item expanded "><a href="../1_Introduction/1_2_Photorealistic_Rendering_and_the_Ray-Tracing_Algorithm.html"><strong aria-hidden="true">1.2.</strong> 照片级真实感渲染与光线追踪算法</a></li><li class="chapter-item expanded "><a href="../1_Introduction/1_3_pbrt_System_Overview.html"><strong aria-hidden="true">1.3.</strong> pbrt：系统概述</a></li><li class="chapter-item expanded "><a href="../1_Introduction/1_4_How_to_Proceed_through_This_Book.html"><strong aria-hidden="true">1.4.</strong> 如何阅读本书</a></li><li class="chapter-item expanded "><a href="../1_Introduction/1_5_Using_and_Understanding_the_Code.html"><strong aria-hidden="true">1.5.</strong> 使用和理解代码</a></li><li class="chapter-item expanded "><a href="../1_Introduction/1_6_A_Brief_History_of_Physically_Based_Rendering.html"><strong aria-hidden="true">1.6.</strong> 基于物理的渲染简史</a></li><li class="chapter-item expanded "><a href="../1_Introduction/Further_Reading.html"><strong aria-hidden="true">1.7.</strong> 延伸阅读</a></li><li class="chapter-item expanded "><a href="../1_Introduction/Exercises.html"><strong aria-hidden="true">1.8.</strong> 练习</a></li></ol></li><li class="chapter-item expanded "><a href="../2_Monte_Carlo_Integration/index.html"><strong aria-hidden="true">2.</strong> 蒙特卡罗积分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2_Monte_Carlo_Integration/2_1_Monte_Carlo_Basics.html"><strong aria-hidden="true">2.1.</strong> 蒙特卡罗：基础知识</a></li><li class="chapter-item expanded "><a href="../2_Monte_Carlo_Integration/2_2_Improving_Efficiency.html"><strong aria-hidden="true">2.2.</strong> 提高效率</a></li><li class="chapter-item expanded "><a href="../2_Monte_Carlo_Integration/2_3_Sampling_Using_the_Inversion_Method.html"><strong aria-hidden="true">2.3.</strong> 使用反演法进行采样</a></li><li class="chapter-item expanded "><a href="../2_Monte_Carlo_Integration/2_4_Transforming_between_Distributions.html"><strong aria-hidden="true">2.4.</strong> 分布之间的转换</a></li><li class="chapter-item expanded "><a href="../2_Monte_Carlo_Integration/Further_Reading.html"><strong aria-hidden="true">2.5.</strong> 延伸阅读</a></li><li class="chapter-item expanded "><a href="../2_Monte_Carlo_Integration/Exercises.html"><strong aria-hidden="true">2.6.</strong> 练习</a></li></ol></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/index.html"><strong aria-hidden="true">3.</strong> 几何与变换</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/3_1_Coordinate_Systems.html"><strong aria-hidden="true">3.1.</strong> 坐标系统</a></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/3_2_n-Tuple_Base_Classes.html"><strong aria-hidden="true">3.2.</strong> n-元组基类</a></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/3_3_Vectors.html"><strong aria-hidden="true">3.3.</strong> 向量</a></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/3_4_Points.html"><strong aria-hidden="true">3.4.</strong> 点</a></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/3_5_Normals.html"><strong aria-hidden="true">3.5.</strong> 法线</a></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/3_6_Rays.html"><strong aria-hidden="true">3.6.</strong> 光线（射线）</a></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/3_7_Bounding_Boxes.html" class="active"><strong aria-hidden="true">3.7.</strong> 边界框（包围盒）</a></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/3_8_Spherical_Geometry.html"><strong aria-hidden="true">3.8.</strong> 球面几何</a></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/3_9_Transformations.html"><strong aria-hidden="true">3.9.</strong> 变换</a></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/3_10_Applying_Transformations.html"><strong aria-hidden="true">3.10.</strong> 应用变换</a></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/3_11_Interactions.html"><strong aria-hidden="true">3.11.</strong> 交互（相互作用）</a></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/Further_Reading.html"><strong aria-hidden="true">3.12.</strong> 延伸阅读</a></li><li class="chapter-item expanded "><a href="../3_Geometry_and_Transformations/Exercises.html"><strong aria-hidden="true">3.13.</strong> 练习</a></li></ol></li><li class="chapter-item expanded "><a href="../4_Radiometry_Spectra_and_Color/index.html"><strong aria-hidden="true">4.</strong> 辐射度量学、光谱与颜色</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../4_Radiometry_Spectra_and_Color/4_1_Radiometry.html"><strong aria-hidden="true">4.1.</strong> 辐射度量学</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">pbr-book-4ed</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="content-wrap">
                            <h1 id="37-边界框bounding-boxes"><a class="header" href="#37-边界框bounding-boxes">3.7 边界框（<a href="https://www.pbr-book.org/4ed/Geometry_and_Transformations/Bounding_Boxes">Bounding Boxes</a>）</a></h1>
<p>系统的许多部分都在轴对齐的空间区域（axis-aligned regions of space）上运行。例如， <strong>pbrt</strong> 中的多线程是通过将图像细分为可以独立处理的 2D 矩形瓦片来实现的，而第 <a href="../7_Primitives_and_Intersection_Acceleration/7_3_Bounding_Volume_Hierarchies.html">7.3</a> 节中的包围体层次结构使用 3D 框来包围场景中的几何原件。 <a href="#Bounds2-definition"><strong>Bounds2</strong></a> 和 <a href="#Bounds3-definition"><strong>Bounds3</strong></a> 模板类用于表示这类区域的范围（extent）。两者都由一个用于表示它们范围的坐标的类型 <strong>T</strong> 来参数化。与之前的向量数学类型一样，我们在这里将重点放在 3D 变体 <a href="#Bounds3-definition"><strong>Bounds3</strong></a> 上，因为 <a href="#Bounds2-definition"><strong>Bounds2</strong></a> 实际上是它的一个子集。</p>
<p><a name="Bounds2-definition"></a></p>
<pre><code class="language-cpp">/** Bounds2 定义 */
template &lt;typename T&gt;
class Bounds2 {
  public:
    /** Bounds2 公有方法 */
    /** Bounds2 公有成员 */
};
</code></pre>
<p><a name="Bounds3-definition"></a></p>
<pre><code class="language-cpp">/** Bounds3 定义 */
template &lt;typename T&gt;
class Bounds3 {
  public:
    /** Bounds3 公有方法 */
    /** Bounds3 公有成员 */
};
</code></pre>
<p>我们使用与之前相同的简写来定义常用边界类型的名称。</p>
<p><a name="Bounds3f"></a></p>
<pre><code class="language-cpp">/** Bounds[23][fi] 定义 */
using Bounds2f = Bounds2&lt;Float&gt;;
using Bounds2i = Bounds2&lt;int&gt;;
using Bounds3f = Bounds3&lt;Float&gt;;
using Bounds3i = Bounds3&lt;int&gt;;
</code></pre>
<p>这类边界框有几种可能的表示方式； <strong>pbrt</strong> 使用 <em>轴对齐边界框（axis-aligned bounding boxes）</em>（AABBs）（AABB包围盒），其中框的边相互垂直并与坐标轴对齐。另一种可能的选择是 <em>定向边界框（oriented bounding boxes）</em>（OBBs）（OBB包围盒），其中框的不同侧的边仍然相互垂直，但不一定与坐标系对齐。一个 3D AABB 可以通过它的一个顶点和三条边的长度来描述，每个长度表示沿 \( x \) 、 \( y \) 和 \( z \) 轴的距离跨度。或者，框的两个对角顶点也可以描述它。我们为 <strong>pbrt</strong> 的 <a href="#Bounds2-definition"><strong>Bounds2</strong></a> 和 <a href="#Bounds3-definition"><strong>Bounds3</strong></a> 类选择了两点表示法；它们存储具有最小坐标值和最大坐标值的顶点的位置。图 <a href="#figure-3-9">3.9</a> 显示了边界框的 2D 插图及其表示。</p>
<pre><code class="language-cpp">/** Bounds3 公有成员 */
Point3&lt;T&gt; pMin, pMax;
</code></pre>
<blockquote>
<p><a name="figure-3-9"></a></p>
<div class="figure-row">
  <img src="figures/pha03f09.svg" width="474" height="157" style="max-width: 100%;">
</div>
<p><strong>图 3.9：轴对齐边界框（AABB）。</strong> <a href="#Bounds2-definition"><strong>Bounds2</strong></a> 和 <a href="#Bounds3-definition"><strong>Bounds3</strong></a> 类仅存储框的最小和最大点的坐标；边界框的其他角在此表示中是隐式的。</p>
</blockquote>
<p>默认构造函数通过将范围设置为无效配置（违反不变量 <strong>pMin.x &lt;= pMax.x</strong>，其他维度类似）来创建一个空框。通过用可表示的最大和最小数字初始化两个角点，任何涉及空框的操作（例如 <strong>Union()</strong> ）都将产生正确的结果。</p>
<pre><code class="language-cpp">/** Bounds3 公有方法 */
Bounds3() {
    T minNum = std::numeric_limits&lt;T&gt;::lowest();
    T maxNum = std::numeric_limits&lt;T&gt;::max();
    pMin = Point3&lt;T&gt;(maxNum, maxNum, maxNum);
    pMax = Point3&lt;T&gt;(minNum, minNum, minNum);
}
</code></pre>
<p>初始化仅包含一个点的边界也是很有用的：</p>
<pre><code class="language-cpp">/** Bounds3 公有方法 */
explicit Bounds3(Point3&lt;T&gt; p) : pMin(p), pMax(p) {}
</code></pre>
<p>如果调用者传递两个角点（ <strong>p1</strong> 和 <strong>p2</strong> ）来定义框，构造函数需要找到它们的分量最小值和最大值，因为不一定是 <strong>p1.x &lt;= p2.x</strong> ，等等。</p>
<pre><code class="language-cpp">/** Bounds3 公有方法 */
Bounds3(Point3&lt;T&gt; p1, Point3&lt;T&gt; p2)
    : pMin(Min(p1, p2)), pMax(Max(p1, p2)) {}
</code></pre>
<p>使用数组索引选择框的两个角点中的一个是很有用的。调试版本中的断言（此处未显示）检查提供的索引是否为 0 或 1。</p>
<pre><code class="language-cpp">/** Bounds3 公有方法 */
Point3&lt;T&gt; operator[](int i) const { return (i == 0) ? pMin : pMax; }
Point3&lt;T&gt; &amp;operator[](int i) { return (i == 0) ? pMin : pMax; }
</code></pre>
<p><strong>Corner()</strong> 方法返回边界框八个角之一的坐标。其逻辑调用 <strong>operator[]</strong> 方法，针对每个维度使用基于 <strong>corner</strong> 的低三位中的零或一值，然后提取相应的分量。如果你觉得不够显而易见，那么通过传入 0 到 7 来验证该方法返回的所有八个角的位置是值得的。</p>
<p>给定一个边界框和一个点， <strong>Union()</strong> 函数返回一个包围该点和原始边界的新边界框。</p>
<pre><code class="language-cpp">/** Bounds3 内联函数 */
template &lt;typename T&gt;
Bounds3&lt;T&gt; Union(const Bounds3&lt;T&gt; &amp;b, Point3&lt;T&gt; p) {
    Bounds3&lt;T&gt; ret;
    ret.pMin = Min(b.pMin, p);
    ret.pMax = Max(b.pMax, p);
    return ret;
}
</code></pre>
<p>一个在这和后续某些函数中应用的细节是，有必要在函数中直接设置 <strong>ret</strong> 的成员变量 <strong>pMin</strong> 和 <strong>pMax</strong>，而不是将 <strong>Min()</strong> 和 <strong>Max()</strong> 的返回值传给 <strong>Bounds3</strong> 构造函数。这个细节源于这样一个事实：如果提供的边界都是退化的（degenerate），那么返回的边界也应该是退化的。如果将退化的范围传递给构造函数，则它会对坐标值进行排序，这最终会导致一个无限的边界。</p>
<p>同样可以构造一个新的边界框，来包围由两个其他边界框所包含的空间。该函数的定义类似于之前的 <strong>Union()</strong> 方法，该方法接受一个 <a href="./3_4_Points.html#Point3*"><strong>Point3f</strong></a> ；不同之处在于第二个框的 <strong>pMin</strong> 和 <strong>pMax</strong> 被用于 <strong>Min()</strong> 和 <strong>Max()</strong> 测试。</p>
<pre><code class="language-cpp">/** Bounds3 内联函数 */
template &lt;typename T&gt;
Bounds3&lt;T&gt; Union(const Bounds3&lt;T&gt; &amp;b1, const Bounds3&lt;T&gt; &amp;b2) {
    Bounds3&lt;T&gt; ret;
    ret.pMin = Min(b1.pMin, b2.pMin);
    ret.pMax = Max(b1.pMax, b2.pMax);
    return ret;
}
</code></pre>
<p>两个边界框的交集可以通过计算它们各自最小坐标的最大值和最大坐标的最小值来找到。（见图 <a href="#figure-3-10">3.10</a>。）</p>
<blockquote>
<p><a name="figure-3-10"></a></p>
<div class="figure-row">
  <img src="figures/pha03f10.svg" width="336" height="220" style="max-width: 100%;">
</div>
<p><strong>图 3.10：两个边界框的交集。</strong> 给定两个边界框， <strong>pMin</strong> 和 <strong>pMax</strong> 点用空心圆表示，它们交集区域的边界框（阴影区域）具有一个最小点（左下角填充圆）其坐标由两个框在每个维度的最小点坐标的最大值给出。同样，它的最大点（右上角填充圆）由两个框的最大坐标的最小值给出。</p>
</blockquote>
<pre><code class="language-cpp">/** Bounds3 内联函数 */
template &lt;typename T&gt;
Bounds3&lt;T&gt; Intersect(const Bounds3&lt;T&gt; &amp;b1, const Bounds3&lt;T&gt; &amp;b2) {
    Bounds3&lt;T&gt; b;
    b.pMin = Max(b1.pMin, b2.pMin);
    b.pMax = Min(b1.pMax, b2.pMax);
    return b;
}
</code></pre>
<p>我们还可以通过观察两个边界框在 \( x \) 、 \( y \) 和 \( z\ ) 中的范围是否重叠来判断它们是否重叠：</p>
<pre><code class="language-cpp">/** Bounds3 内联函数 */
template &lt;typename T&gt;
bool Overlaps(const Bounds3&lt;T&gt; &amp;b1, const Bounds3&lt;T&gt; &amp;b2) {
    bool x = (b1.pMax.x &gt;= b2.pMin.x) &amp;&amp; (b1.pMin.x &lt;= b2.pMax.x);
    bool y = (b1.pMax.y &gt;= b2.pMin.y) &amp;&amp; (b1.pMin.y &lt;= b2.pMax.y);
    bool z = (b1.pMax.z &gt;= b2.pMin.z) &amp;&amp; (b1.pMin.z &lt;= b2.pMax.z);
    return (x &amp;&amp; y &amp;&amp; z);
}
</code></pre>
<p>三个一维包含（containment）测试判断给定点是否在边界框内。</p>
<pre><code class="language-cpp">/** Bounds3 内联函数 */
template &lt;typename T&gt;
bool Inside(Point3&lt;T&gt; p, const Bounds3&lt;T&gt; &amp;b) {
    return (p.x &gt;= b.pMin.x &amp;&amp; p.x &lt;= b.pMax.x &amp;&amp;
            p.y &gt;= b.pMin.y &amp;&amp; p.y &lt;= b.pMax.y &amp;&amp;
            p.z &gt;= b.pMin.z &amp;&amp; p.z &lt;= b.pMax.z);
}
</code></pre>
<p><strong>Inside()</strong> 的 <strong>InsideExclusive()</strong> 变体不将上边界上的点视为在边界内。它主要适用于整数类型的边界。</p>
<pre><code class="language-cpp">/** Bounds3 内联函数 */
template &lt;typename T&gt;
bool InsideExclusive(Point3&lt;T&gt; p, const Bounds3&lt;T&gt; &amp;b) {
    return (p.x &gt;= b.pMin.x &amp;&amp; p.x &lt; b.pMax.x &amp;&amp;
            p.y &gt;= b.pMin.y &amp;&amp; p.y &lt; b.pMax.y &amp;&amp;
            p.z &gt;= b.pMin.z &amp;&amp; p.z &lt; b.pMax.z);
}
</code></pre>
<p><strong>DistanceSquared()</strong> 返回一个点到边界框的平方距离，如果该点在框内，则返回零。计算的几何设置如图 <a href="#figure-3-11">3.11</a> 所示。在每个维度中计算点到框的距离后，通过将每个一维距离的平方相加来找到平方距离。</p>
<blockquote>
<p><a name="figure-3-11"></a></p>
<div class="figure-row">
  <img src="figures/pha03f11.svg" width="341" height="166" style="max-width: 100%;">
</div>
<p><strong>图 3.11：计算点到轴对齐边界框（AABB）的平方距离。</strong> 首先，我们在每个维度上找到点到框的距离。这里，左上角的空心圆表示的点位于框的左上方，因此其 \( x \) 和 \( y \) 距离分别为 <strong>pMin.x - p.x</strong> 和 <strong>pMin.y - p.y</strong> 。另一个空心圆表示的点位于框的右侧，但在 \( y \) 维度上与框重叠，距离分别为 <strong>p.x - pMax.x</strong> 和零。 <a href="#DistanceSquared"><strong>Bounds3::DistanceSquared()</strong></a> 中的逻辑是通过找到零与每个维度中最小和最大点的距离中的最大值来计算这些距离。</p>
</blockquote>
<p><a name="DistanceSquared"></a></p>
<pre><code class="language-cpp">/** Bounds3 内联函数 */
template &lt;typename T, typename U&gt;
auto DistanceSquared(Point3&lt;T&gt; p, const Bounds3&lt;U&gt; &amp;b) {
    using TDist = decltype(T{} - U{});
    TDist dx = std::max&lt;TDist&gt;({0, b.pMin.x - p.x, p.x - b.pMax.x});
    TDist dy = std::max&lt;TDist&gt;({0, b.pMin.y - p.y, p.y - b.pMax.y});
    TDist dz = std::max&lt;TDist&gt;({0, b.pMin.z - p.z, p.z - b.pMax.z});
    return Sqr(dx) + Sqr(dy) + Sqr(dz);
}
</code></pre>
<p>从一个点到边界框的距离计算很简单，尽管需要间接使用 <a href="./3_3_Vectors.html#TupleLength-definition"><strong>TupleLength</strong></a> 来判断正确的返回类型。</p>
<pre><code class="language-cpp">/** Bounds3 内联函数 */
template &lt;typename T, typename U&gt;
auto Distance(Point3&lt;T&gt; p, const Bounds3&lt;U&gt; &amp;b) {
    auto dist2 = DistanceSquared(p, b);
    using TDist = typename TupleLength&lt;decltype(dist2)&gt;::type;
    return std::sqrt(TDist(dist2));
}
</code></pre>
<p><strong>Expand()</strong> 函数在所有维度上以一个常数因子扩大边界框。</p>
<pre><code class="language-cpp">/** Bounds3 内联函数 */
template &lt;typename T, typename U&gt;
Bounds3&lt;T&gt; Expand(const Bounds3&lt;T&gt; &amp;b, U delta) {
    Bounds3&lt;T&gt; ret;
    ret.pMin = b.pMin - Vector3&lt;T&gt;(delta, delta, delta);
    ret.pMax = b.pMax + Vector3&lt;T&gt;(delta, delta, delta);
    return ret;
}
</code></pre>
<p><strong>Diagonal()</strong> 返回边界框对角线上从最小点指向最大点的向量。</p>
<pre><code class="language-cpp">/** Bounds3 公有方法 */
Vector3&lt;T&gt; Diagonal() const { return pMax - pMin; }
</code></pre>
<p>计算框六个面的表面积和内部体积的方法也很有用。（这是 <strong>Bounds2</strong> 和 <strong>Bounds3</strong> 有区别的地方：这些方法在 <strong>Bounds2</strong> 中不可用，尽管它确实有一个 <strong>Area()</strong> 方法。）</p>
<pre><code class="language-cpp">/** Bounds3 公有方法 */
T SurfaceArea() const {
    Vector3&lt;T&gt; d = Diagonal();
    return 2 * (d.x * d.y + d.x * d.z + d.y * d.z);
}
</code></pre>
<pre><code class="language-cpp">/** Bounds3 公有方法 */
T Volume() const {
    Vector3&lt;T&gt; d = Diagonal();
    return d.x * d.y * d.z;
}
</code></pre>
<p><a href="#MaxDimension"><strong>Bounds3::MaxDimension()</strong></a> 方法返回三个轴中最长的轴的索引。这在例如构建某些光线相交加速结构时，决定要细分哪个轴时是非常有用的。</p>
<p><a name="MaxDimension"></a></p>
<pre><code class="language-cpp">/** Bounds3 公有方法 */
int MaxDimension() const {
    Vector3&lt;T&gt; d = Diagonal();
    if (d.x &gt; d.y &amp;&amp; d.x &gt; d.z) return 0;
    else if (d.y &gt; d.z)         return 1;
    else                        return 2;
}
</code></pre>
<p><a href="../2_Monte_Carlo_Integration/2_3_Sampling_Using_the_Inversion_Method.html#Lerp"><strong>Lerp()</strong></a> 通过给定在各维度上的量值来在框的各个角之间线性插值。</p>
<pre><code class="language-cpp">/** Bounds3 公有方法 */
Point3f Lerp(Point3f t) const {
    return Point3f(pbrt::Lerp(t.x, pMin.x, pMax.x),
                   pbrt::Lerp(t.y, pMin.y, pMax.y),
                   pbrt::Lerp(t.z, pMin.z, pMax.z));
}
</code></pre>
<p><strong>Offset()</strong> 实际上是 <strong>Lerp()</strong> 的反向操作。它返回一个点相对于框角的连续位置，其中位于最小角落的点具有偏移 \( (0,0,0) \) ，位于最大角落的点具有偏移 \( (1,1,1) \) ，依此类推。</p>
<pre><code class="language-cpp">/** Bounds3 公有方法 */
Vector3f Offset(Point3f p) const {
    Vector3f o = p - pMin;
    if (pMax.x &gt; pMin.x) o.x /= pMax.x - pMin.x;
    if (pMax.y &gt; pMin.y) o.y /= pMax.y - pMin.y;
    if (pMax.z &gt; pMin.z) o.z /= pMax.z - pMin.z;
    return o;
}
</code></pre>
<p><a href="#Bounds3-definition"><strong>Bounds3</strong></a> 还提供了一种方法，返回包围边界框的球体的中心和半径。一般来说，这可能比直接包围 <a href="#Bounds3-definition"><strong>Bounds3</strong></a> 原始内容的球体适配得松散的多，但对于某些几何操作，使用球体比使用框体更容易，在这种情况下，较差的适配可能是一个可接受的权衡。</p>
<pre><code class="language-cpp">/** Bounds3 公有方法 */
void BoundingSphere(Point3&lt;T&gt; *center, Float *radius) const {
    *center = (pMin + pMax) / 2;
    *radius = Inside(*center, *this) ? Distance(*center, pMax) : 0;
}
</code></pre>
<p>下面两个直白的方法测试空的（empty）和退化的（degenerate）边界框。请注意，“空”意味着边界框的体积为零，但并不一定意味着它的表面积为零。</p>
<pre><code class="language-cpp">/** Bounds3 公有方法 */
bool IsEmpty() const {
    return pMin.x &gt;= pMax.x || pMin.y &gt;= pMax.y || pMin.z &gt;= pMax.z;
}
bool IsDegenerate() const {
    return pMin.x &gt; pMax.x || pMin.y &gt; pMax.y || pMin.z &gt; pMax.z;
}
</code></pre>
<p>最后，对于整数边界，有一个迭代器类满足 C++ 前向迭代器的要求（即，它只能向前推进）。细节稍显繁琐且不那么有趣，因此书中未包含代码。拥有这个定义使得可以编写使用基于范围的 <strong>for</strong> 循环来迭代边界框中的整数坐标的代码：</p>
<pre><code class="language-cpp">    Bounds2i b = ...;
    for (Point2i p : b) {
        //  …
    }
</code></pre>
<p>根据实现，迭代会达到但不访问每个维度的最大范围的点。</p>

                        </div>
                        <div class="sidetoc">
                            <nav class="pagetoc"></nav>
                        </div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../3_Geometry_and_Transformations/3_6_Rays.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../3_Geometry_and_Transformations/3_8_Spherical_Geometry.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../3_Geometry_and_Transformations/3_6_Rays.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../3_Geometry_and_Transformations/3_8_Spherical_Geometry.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/pagetoc.js"></script>


    </div>
    </body>
</html>